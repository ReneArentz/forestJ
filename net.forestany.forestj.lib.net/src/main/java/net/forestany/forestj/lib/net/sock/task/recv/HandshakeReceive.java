package net.forestany.forestj.lib.net.sock.task.recv;

/**
 * Handshake task class to receive a short triple handshake over a socket instance. Only TCP supported.
 * Handshake consists of two bytes:
 * First byte is determined by a constant within net.forestany.forestj.lib.net.sock.task.Task class. This will always be checked.
 * Second byte is a random value between 0 and 255, generated by handshake sender.
 * After these two bytes has been sent, the receiver will increase the second byte by 1 and will send both bytes back.
 * Sender will check if increased second byte has correct value and also increase the second byte, sending it again to receiver.
 * Receiver will check the second byte one last time. If the correct value is approved, triple handshake over TCP was successful.
 * 
 * @param <T>	java socket class parameter
 */
public class HandshakeReceive<T> extends net.forestany.forestj.lib.net.sock.task.Task<T> {
	/**
	 * interface delegate definition which can be instanced outside of net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive&lt;T&gt; class to execute code after triple handshake
	 */
	public interface IDelegateAdditionalExecution {
		/**
		 * execute additional code
		 */
		void AdditionalExecution();
	}
	
	private boolean b_endless = false;
	private int i_taskIntervalMilliseconds = 0;
	private IDelegateAdditionalExecution itf_delegateAdditionalExecution = null;
	
	/**
	 * get endless flag
	 * 
	 * @return boolean
	 */
	private boolean getEndless() {
		return this.b_endless;
	}
	
	/**
	 * set endless flag
	 * 
	 * @param p_b_value boolean
	 */
	public void setEndless(boolean p_b_value) {
		this.b_endless = p_b_value;
	}
	
	/**
	 * get task interval milliseconds
	 * 
	 * @return int
	 */
	private int getTaskIntervalMilliseconds() {
		return this.i_taskIntervalMilliseconds;
	}
	
	/**
	 * set task interval milliseconds
	 * 
	 * @param p_i_value int
	 * @throws IllegalArgumentException must be a positive integer
	 */
	public void setTaskIntervalMilliseconds(int p_i_value) throws IllegalArgumentException {
 		/* check timeout value for queue */
		if (p_i_value < 1) {
			throw new IllegalArgumentException("Task timeout must be at least '1' millisecond, but was set to '" + p_i_value + "' millisecond(s)");
		}
		
		this.i_taskIntervalMilliseconds = p_i_value;
 	}
	
	/**
	 * get additional execution delegate
	 * 
	 * @return IDelegateAdditionalExecution
	 */
	private IDelegateAdditionalExecution getDelegateAdditionalExecution() {
		return this.itf_delegateAdditionalExecution;
	}
	
	/**
	 * set additional execution delegate
	 * 
	 * @param p_itf_delegateAdditionalExecution IDelegateAdditionalExecution
	 */
	public void setDelegateAdditionalExecution(IDelegateAdditionalExecution p_itf_delegateAdditionalExecution) {
		if (this.e_type == net.forestany.forestj.lib.net.sock.Type.TCP) {
			this.itf_delegateAdditionalExecution = p_itf_delegateAdditionalExecution;
		}
	}
	
	/**
	 * standard constructor
	 */
	public HandshakeReceive() {
		
	}
	
	/**
	 * Creating handshake task instance with all it's parameters and settings
	 * 
	 * @param p_e_type					specifies socket type of socket task
	 */
	public HandshakeReceive(net.forestany.forestj.lib.net.sock.Type p_e_type) {
		super(p_e_type);
	}
	
	/**
	 * method to get socket task class type for creating new instances with declared constructor
	 * @return		class type of socket task as Class&lt;?&gt;
	 */
	public Class<?> getSocketTaskClassType() {
		return net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive.class;
	}
	
	/**
	 * method to clone this socket task with another socket task instance
	 * @param p_o_sourceTask		another socket task instance as source for all it's parameters and settings
	 */
	public void cloneFromOtherTask(net.forestany.forestj.lib.net.sock.task.Task<T> p_o_sourceTask) {
		this.cloneBasicFields(p_o_sourceTask);
		
		try { this.b_endless = ((net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive<T>)p_o_sourceTask).getEndless(); } catch (Exception o_exc) { /* NOP */ }
		try { this.i_taskIntervalMilliseconds = ((net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive<T>)p_o_sourceTask).getTaskIntervalMilliseconds(); } catch (Exception o_exc) { /* NOP */ }
		try { this.itf_delegateAdditionalExecution = ((net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive<T>)p_o_sourceTask).getDelegateAdditionalExecution(); } catch (Exception o_exc) { /* NOP */ }
	}
	
	/**
	 * runTask method of receiving a handshake.
	 * 
	 * @throws Exception	any exception of implementation that could happen will be caught by abstract Task class, see details in protocol methods in net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive
	 */
	protected void runTask() throws Exception {
		do {
			this.handshakeTask();
													
			/* set stop flag to stop task/socket thread */
			this.b_stop = this.getToken().isCanceled();
			
			/* if task/socket is not canceled and task timeout is set */
			if ((!this.getToken().isCanceled()) && (this.i_taskIntervalMilliseconds > 0)) {
				/* wait task timeout */
				Thread.sleep(this.i_taskIntervalMilliseconds);
			}
		} while ((this.b_endless) && (!this.getToken().isCanceled()));
	}
	
	/**
	 * method containing logic to receive a handshake.
	 * 
	 * @throws Exception	any exception of implementation that could happen will be caught by abstract Task class, see details in protocol methods in net.forestany.forestj.lib.net.sock.task.recv.HandshakeReceive
	 */
	private void handshakeTask() throws Exception {
		/* only TCP supported */
		if (this.e_type == net.forestany.forestj.lib.net.sock.Type.TCP) {
			/* help variables and byte array for receiving handshake bytes */
			byte[] a_handshakeBytes = null;
			int i_maxAttempts = 40;
			int i_attempts = 1;
			
			do {
				/* receiving both handshake bytes, first byte is a constant and the second is a random number between 0 and 255 determined by other communication side */
				a_handshakeBytes = this.receiveBytes(2, 2);
				
				if (a_handshakeBytes.length == 0) {
					throw new IllegalStateException("Handshake failed. Protocol for receiving handshake failed completely or was not intended (check availability call over TCP)");
				}
				
														net.forestany.forestj.lib.Global.ilogFiner("Received handshake: '" + net.forestany.forestj.lib.Helper.printByteArray(a_handshakeBytes, false) + "'");
				
				/* first byte must match constant within Task class */
				if (a_handshakeBytes[0] != net.forestany.forestj.lib.net.sock.task.Task.BY_ACK_BYTE) {
															net.forestany.forestj.lib.Global.ilogWarning("Invalid first byte of handshake[" + net.forestany.forestj.lib.Helper.printByteArray(new byte[] {a_handshakeBytes[0]}, false).trim() + "], must be [" + net.forestany.forestj.lib.Helper.printByteArray(new byte[] {net.forestany.forestj.lib.net.sock.task.Task.BY_ACK_BYTE}, false).trim() + "]; retry after 25 milliseconds");
					
					/* wait 25 milliseconds to receive handshake bytes again */
					Thread.sleep(25);
					
					if (i_attempts >= i_maxAttempts) { /* all attempts failed, so protocol for receiving handshake failed completely */
						throw new IllegalStateException("Handshake failed, receiver first step, after " + i_attempts + " attempts");
					}
				}
			} while (a_handshakeBytes[0] != net.forestany.forestj.lib.net.sock.task.Task.BY_ACK_BYTE); /* loop ended if first byte match constant */
			
			/* ------------------------------------------------------ */
			
			/* increase received random number in second byte, this will be expected by other communication side */
			a_handshakeBytes[1]++;
			/* remember increased value of second byte for later use */
			byte by_remember = a_handshakeBytes[1];
			
			/* help variables */
			boolean b_retry = true;
			i_maxAttempts = 40;
			i_attempts = 1;
			
			do {
				try {
															net.forestany.forestj.lib.Global.ilogFiner("Send handshake: '" + net.forestany.forestj.lib.Helper.printByteArray(a_handshakeBytes, false) + "'");
					
					/* send both handshake bytes with modified second byte */
					this.sendBytes(a_handshakeBytes, a_handshakeBytes.length);
					b_retry = false;
				} catch (Exception o_exc) {
															net.forestany.forestj.lib.Global.ilogWarning("Could not send handshake[" + net.forestany.forestj.lib.Helper.printByteArray(a_handshakeBytes, false).trim() + "]; retry after 25 milliseconds");
					
					/* wait 25 milliseconds to send handshake bytes again */
					Thread.sleep(25);
					
					if (i_attempts >= i_maxAttempts) { /* all attempts failed, so protocol for receiving handshake failed completely */
						throw new Exception("Handshake failed, receiver second step, after " + i_attempts + " attempts");
					}
				}
			} while (b_retry); /* loop ended if handshake bytes could be sent without any exception */
			
			/* ------------------------------------------------------ */
			
			/* help variables and reset byte array for receiving handshake bytes */
			a_handshakeBytes = null;
			i_maxAttempts = 40;
			i_attempts = 1;
			
			do {
				/* receiving both handshake bytes, first byte is a constant and the second byte have been increased of other communication side */
				a_handshakeBytes = this.receiveBytes(2, 2);
				
														net.forestany.forestj.lib.Global.ilogFine("Received handshake: '" + net.forestany.forestj.lib.Helper.printByteArray(a_handshakeBytes, false) + "'");
				
				/* first byte must match constant within Task class */
				if (a_handshakeBytes[0] != net.forestany.forestj.lib.net.sock.task.Task.BY_ACK_BYTE) {
															net.forestany.forestj.lib.Global.ilogWarning("Invalid first byte of handshake[" + net.forestany.forestj.lib.Helper.printByteArray(new byte[] {a_handshakeBytes[0]}, false).trim() + "], must be [" + net.forestany.forestj.lib.Helper.printByteArray(new byte[] {net.forestany.forestj.lib.net.sock.task.Task.BY_ACK_BYTE}, false).trim() + "]; retry after 25 milliseconds");
					
					/* wait 25 milliseconds to receive handshake bytes again */
					Thread.sleep(25);
					
					if (i_attempts >= i_maxAttempts) { /* all attempts failed, so protocol for receiving handshake failed completely */
						throw new IllegalStateException("Handshake failed, receiver first step, after " + i_attempts + " attempts");
					}
				} else if (a_handshakeBytes[1] != (by_remember + 0x01)) { /* second byte must match remembered increased value of second byte + 1 */
															net.forestany.forestj.lib.Global.ilogWarning("Invalid second byte of handshake[" + net.forestany.forestj.lib.Helper.printByteArray(new byte[] {a_handshakeBytes[1]}, false).trim() + "], should be [" + net.forestany.forestj.lib.Helper.printByteArray(new byte[] {(byte)(by_remember + 1)}, false).trim() + "]; retry after 25 milliseconds");
					
					/* wait 25 milliseconds to receive handshake bytes again */
					Thread.sleep(25);
					
					if (i_attempts >= i_maxAttempts) { /* all attempts failed, so protocol for receiving handshake failed completely */
						throw new Exception("Handshake failed, receiver third step, after " + i_attempts + " attempts");
					}
				}
			} while ( (a_handshakeBytes[0] != net.forestany.forestj.lib.net.sock.task.Task.BY_ACK_BYTE) && (a_handshakeBytes[1] != (by_remember + 0x01)) ); /* see both if conditions above */
			
			/* ------------------------------------------------------ */
			
													net.forestany.forestj.lib.Global.ilog("TCP Triple Handshake finished successfully");
			
			/* execute additional code with delegate if it is set */
			if (this.itf_delegateAdditionalExecution != null) {
	        	this.itf_delegateAdditionalExecution.AdditionalExecution();
	        }
		} else if (this.e_type == net.forestany.forestj.lib.net.sock.Type.UDP) {
			throw new UnsupportedOperationException("Not implemented for UDP protocol");
		} else {
			throw new UnsupportedOperationException("Not implemented");
		}
	}
}
